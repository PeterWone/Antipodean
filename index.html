<html>

<head>
  <title>Antipodean</title>
  <link href="./md.css" rel="stylesheet">
</head>

<body>
  <div id="navbar-container">
    <div id="navbar">
      <button id="prev-chapter" class="nav-button no-print">Previous</button>
      <h1 id="chapter-title" class="toggle-toc">Antipodean</h1>
      <button id="next-chapter" class="nav-button no-print">Next</button>
    </div>
  </div>
  <div id="toc" class="hidden">
    <h2>Table of Contents</h2>
    <ul id="markdown-links"></ul>
  </div>
  <div id="content"></div>
  <div id="hidden-content" style="display: none;"></div> <!-- Hidden div for temporary content -->

  <script>
    const repoUrl = `https://api.github.com/repos/${location.hostname.split('.')[0]}/${location.pathname.split('/')[1]}/contents/`; // Dynamically construct repoUrl
    const githubPagesBaseUrl = `https://${location.hostname}/${location.pathname.split('/')[1]}/`;
    const repoName = repoUrl.split('/')[4]; // Extract the repository name dynamically
    const toc = document.getElementById('toc');
    const content = document.getElementById('content');
    const hiddenContent = document.getElementById('hidden-content');
    const prevButton = document.getElementById('prev-chapter');
    const nextButton = document.getElementById('next-chapter');
    const chapterTitle = document.getElementById('chapter-title');
    let markdownFiles = [];
    let currentIndex = 0;

    // Convert vertical scroll attempts to horizontal scrolling for the content
    content.addEventListener('wheel', (e) => {
      if (e.deltaY !== 0) {
        e.preventDefault();
        content.scrollLeft += e.deltaY;
      }
    });

    // Toggle between TOC and content when the title is clicked
    chapterTitle.addEventListener('click', () => {
      toc.classList.toggle('hidden');
      content.classList.toggle('hidden');
      if (!toc.classList.contains('hidden')) {
        scrollToCurrentChapter(); // Ensure the current chapter is visible
      }
    });

    async function fetchMarkdownFiles() {
      try {
        const response = await fetch(repoUrl);
        const files = await response.json();
        markdownFiles = files.filter(file => file.name.endsWith('.md')).sort((a, b) => a.name.localeCompare(b.name));

        const arcs = {}; // Object to group files by arcs
        markdownFiles.forEach(file => {
          const match = file.name.match(/^(\d+)-/); // Match leading numbers
          const arcNumber = match ? Math.ceil(parseInt(match[1]) / 10) : 1; // Group by tens
          const arcName = `Arc ${arcNumber}`;
          if (!arcs[arcName]) {
            arcs[arcName] = [];
          }
          arcs[arcName].push(file);
        });

        Object.entries(arcs).forEach(([arcName, files]) => {
          const arcHeader = document.createElement('h3');
          arcHeader.textContent = arcName;
          toc.appendChild(arcHeader);

          const arcList = document.createElement('ul');
          files.forEach((file, index) => {
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = "#";
            link.textContent = file.name
              .replace(/^\d+-/, '') // Remove leading numbers and dash
              .replace(/\.md$/, '') // Remove extension
              .replace(/-/g, ' '); // Replace dashes with spaces
            link.addEventListener('click', (e) => {
              e.preventDefault();
              loadContent(index);
              toc.classList.add('hidden'); // Hide TOC
              content.classList.remove('hidden'); // Show content
            });
            listItem.appendChild(link);
            arcList.appendChild(listItem);
          });
          toc.appendChild(arcList);
        });

        // Load the last selected page or the blurb (first chapter file alphabetically)
        const lastSelectedPage = localStorage.getItem('lastSelectedPage');
        const lastIndex = markdownFiles.findIndex(file => file.name === lastSelectedPage);
        if (lastIndex !== -1) {
          loadContent(lastIndex);
        } else if (markdownFiles.length > 0) {
          loadContent(0);
        }
      } catch (error) {
        console.error("Error fetching markdown files:", error);
      }
    }

    async function loadContent(index) {
      try {
        currentIndex = index;
        const fileName = markdownFiles[index].name;
        const response = await fetch(githubPagesBaseUrl + fileName.replace(/\.md$/, '.html'));
        const html = await response.text();
        hiddenContent.innerHTML = html; // Load content into the hidden div

        const markdownBody = hiddenContent.querySelector('.markdown-body'); // Look for the div with class markdown-body
        // Find the first <h1> child that contains an <a> child and remove it
        const h1WithAnchor = markdownBody.querySelector('h1');
        if (h1WithAnchor) {
          markdownBody.removeChild(h1WithAnchor);
        }
        content.innerHTML = markdownBody ? markdownBody.innerHTML : '<p>Content not found.</p>'; // Extract and set content
        hiddenContent.innerHTML = ''; // Clear the hidden div

        const chapterTitleText = fileName
          .replace(/\.md$/, '') // Remove extension
          .replace(/\.(?=[a-zA-Z])/g, ' ') // Period followed by a letter becomes a space
          .replace(/-/g, ' '); // Replace dashes with spaces
        chapterTitle.textContent = `${repoName} â€” ${chapterTitleText}`; // Set full title dynamically
        updateNavButtons();
        highlightCurrentChapter();
        content.scrollTop = 0; // Scroll content pane to the top
      } catch (error) {
        console.error("Error loading content:", error);
      }
    }

    function updateNavButtons() {
      prevButton.disabled = currentIndex === 0;
      nextButton.disabled = currentIndex === markdownFiles.length - 1;
    }

    function highlightCurrentChapter() {
      const tocLinks = toc.querySelectorAll('li');
      tocLinks.forEach((link, index) => {
        link.classList.toggle('current-chapter', index === currentIndex);
      });
    }

    function scrollToCurrentChapter() {
      const currentChapter = toc.querySelector('.current-chapter');
      if (currentChapter) {
        currentChapter.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    prevButton.addEventListener('click', () => {
      if (currentIndex > 0) {
        loadContent(currentIndex - 1);
      }
    });

    nextButton.addEventListener('click', () => {
      if (currentIndex < markdownFiles.length - 1) {
        loadContent(currentIndex + 1);
      }
    });

    fetchMarkdownFiles();
  </script>

  <script src="js/smartquotes.min.js"></script>
  <script>smartquotes();</script>
</body>

</html>